from random import shuffle, randrange


def make_maze(w=4, h=6):
    """
    Generates a maze using the randomized depth-first search algorithm.

    This function creates a maze of width `w` and height `h`, 
    where at least one of the two dimensions is greater than 2 .
    The maze is generated by starting from a random cell and then randomly 
    choosing a neighboring cell to connect until all cells are visited. 
    The function returns a string representation of the maze, 
    where walls are represented by "+", "-", and "|" characters.

    :param w: Optional; the width of the maze. Defaults to 8.
    :param h: Optional; the height of the maze. Defaults to 8.
    :type w: int, optional
    :type h: int, optional
    :return: A string representing the maze.
    :rtype: str

    Example:
       > print(make_maze(3, 3))
        +---+---+---+
                    |
        +   +---+---+
        |   |       |
        +   +   +---+
        |
        +---+---+---+
    """
    
    vis = [[0] * w + [1] for _ in range(h)] + [[1] * (w + 1)]
    ver = [["|   "] * w + ['|'] for _ in range(h)] + [[]]
    hor = [["+---"] * w + ['+'] for _ in range(h + 1)]

    def walk(x, y):
        """
        Recursively walks through the grid to carve out the maze.

        :param x: The current x-coordinate in the maze
        :type x: int
        :param y: The current x-coordinate in the maze
        :type y: int

        This function marks the current cell as visited and randomly
        selects a new direction to move (north, south, east, or west).
        If the chosen cell is unvisited, the function carves a path
        in the corresponding direction and recursively calls itself
        with the new coordinates. This process continues until all cells
        are visited, ensuring a complete maze is generated.
        """
        vis[y][x] = 1

        d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]
        shuffle(d)
        for (xx, yy) in d:
            if vis[yy][xx]:
                continue
            if xx == x:
                hor[max(y, yy)][x] = "+   "
            if yy == y:
                ver[y][max(x, xx)] = "    "
            walk(xx, yy)
            
    walk(randrange(w), randrange(h))

    # Leave the north-west and south-east corners open
    ver[0][0] = "    "
    ver[h - 1][w] = "    "

    s = ""
    for (a, b) in zip(hor, ver):
        s += ''.join(a + ['\n'] + b + ['\n'])
    return s
